From d1121bd1da63415efbb7e21f67d4eb8b8c807f36 Mon Sep 17 00:00:00 2001
From: Michael Puerrer <Michael.Puerrer@ligo.org>
Date: Fri, 17 Nov 2017 20:33:29 +0100
Subject: [PATCH 10/18] Major cleaning up of TEOBv4ROM code

Still some fprintfs left and some other minor things to take care of.
---
 lalsimulation/src/LALSimIMR.h               |   4 +-
 lalsimulation/src/LALSimIMREOBNRv2.h        |  10 +
 lalsimulation/src/LALSimIMRSpinAlignedEOB.c |   2 +-
 lalsimulation/src/LALSimIMRTEOBv4ROM.c      | 892 ++++------------------------
 4 files changed, 113 insertions(+), 795 deletions(-)

diff --git a/lalsimulation/src/LALSimIMR.h b/lalsimulation/src/LALSimIMR.h
index 9942ca1..1c58c77 100644
--- a/lalsimulation/src/LALSimIMR.h
+++ b/lalsimulation/src/LALSimIMR.h
@@ -212,8 +212,8 @@ int XLALSimIMRSEOBNRv4ROMFrequencyOfTime(REAL8 *frequency, REAL8 t, REAL8 m1SI,
 
 /* in module LALSimIMRTEOBv4ROM.c */
 
-int XLALSimIMRTEOBv4ROM(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, REAL8 lambda1, REAL8 lambda2, INT4 nk_max);
-int XLALSimIMRTEOBv4ROMFrequencySequence(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, REAL8 phiRef, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, REAL8 lambda1, REAL8 lambda2, INT4 nk_max);
+int XLALSimIMRTEOBv4ROM(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, REAL8 lambda1, REAL8 lambda2);
+int XLALSimIMRTEOBv4ROMFrequencySequence(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, REAL8 phiRef, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, REAL8 lambda1, REAL8 lambda2);
 
 
 /* in module LALSimIMRPSpinInspiralRD.c */
diff --git a/lalsimulation/src/LALSimIMREOBNRv2.h b/lalsimulation/src/LALSimIMREOBNRv2.h
index c81756d..686c251 100644
--- a/lalsimulation/src/LALSimIMREOBNRv2.h
+++ b/lalsimulation/src/LALSimIMREOBNRv2.h
@@ -500,6 +500,16 @@ typedef struct tagPr3In
 
 } pr3In;
 
+#ifdef __GNUC__
+#define UNUSED __attribute__ ((unused))
+#else
+#define UNUSED
+#endif
+
+UNUSED REAL8 XLALSimNSNSMergerFreq(
+ TidalEOBParams *tidal1, /**< Tidal parameters of body 1 */
+ TidalEOBParams *tidal2  /**< Tidal parameters of body 2 */
+);
 
 #if 0
 {				/* so that editors will match succeeding brace */
diff --git a/lalsimulation/src/LALSimIMRSpinAlignedEOB.c b/lalsimulation/src/LALSimIMRSpinAlignedEOB.c
index 81a9c94..c4c95cc 100644
--- a/lalsimulation/src/LALSimIMRSpinAlignedEOB.c
+++ b/lalsimulation/src/LALSimIMRSpinAlignedEOB.c
@@ -158,7 +158,7 @@ UNUSED REAL8 XLALSimUniversalRelationomega03TidalVSlambda3Tidal(
  * See Eq.(2) in https://arxiv.org/pdf/1504.01764.pdf with coefficients
  * given by the 3rd row of Table II therein. Compared to NR for 0 <= kappa2T <= 500
  */
-static UNUSED REAL8 XLALSimNSNSMergerFreq(
+UNUSED REAL8 XLALSimNSNSMergerFreq(
                                        TidalEOBParams *tidal1, /**< Tidal parameters of body 1 */
                                        TidalEOBParams *tidal2  /**< Tidal parameters of body 2 */
 )
diff --git a/lalsimulation/src/LALSimIMRTEOBv4ROM.c b/lalsimulation/src/LALSimIMRTEOBv4ROM.c
index 74bc902..cd4f1cd 100644
--- a/lalsimulation/src/LALSimIMRTEOBv4ROM.c
+++ b/lalsimulation/src/LALSimIMRTEOBv4ROM.c
@@ -56,15 +56,20 @@
 #ifdef LAL_HDF5_ENABLED
 #include <lal/H5FileIO.h>
 // FIXME: change these to our datafile and version number 1.0.0
-static const char ROMDataHDF5[] = "SEOBNRv4ROM_v2.0.hdf5";
-static const INT4 ROMDataHDF5_VERSION_MAJOR = 2;
-static const INT4 ROMDataHDF5_VERSION_MINOR = 0;
-static const INT4 ROMDataHDF5_VERSION_MICRO = 0;
+//static const char ROMDataHDF5[] = "SEOBNRv4ROM_v2.0.hdf5";
+//static const char ROMDataHDF5[] = "/Users/mpuer/Documents/gpsurrogate/src/TEOB-LAL-implementation/TEOBv4_surrogate.hdf5";
+// FIXME: missing attributes in HDF5 file: Email, Description (rather than description), version_major, version_minor, version_micro
+static const char ROMDataHDF5[] = "TEOBv4_surrogate.hdf5";
+// FIXME: uncomment after adding attributes
+// static const INT4 ROMDataHDF5_VERSION_MAJOR = 1;
+// static const INT4 ROMDataHDF5_VERSION_MINOR = 0;
+// static const INT4 ROMDataHDF5_VERSION_MICRO = 0;
 #endif
 
 #include <lal/LALSimInspiral.h>
 #include <lal/LALSimIMR.h>
 
+#include "LALSimIMREOBNRv2.h"
 #include "LALSimInspiralPNCoefficients.c"
 #include "LALSimIMRSEOBNRROMUtilities.c"
 
@@ -75,16 +80,10 @@ static const INT4 ROMDataHDF5_VERSION_MICRO = 0;
 
 
 // TODO:
-// D add lambda1,2 args
-// D add prototypes
-// * remove the glueing functions -- will be easier to copy logic from earlier code
-// D test reading of HDF5 test data
-// D implement code to compute kernel and gpr
-// * compute and check amp,phi at EIM nodes
-// * assemble waveform and check against python output
 // * add waveform approximant and glueing code in LALSimInspiral
-// remove all debugging code
-// add more checks and tests
+// * remove all debugging code: fprintf statements
+// * add more checks and tests
+// * take care of all FIXMEs
 
 
 #ifdef LAL_PTHREAD_LOCK
@@ -93,12 +92,6 @@ static pthread_once_t TEOBv4ROM_is_initialized = PTHREAD_ONCE_INIT;
 
 /*************** type definitions ******************/
 
-typedef struct tagTEOBv4ROMdataDS_coeff
-{
-  gsl_vector* c_amp;
-  gsl_vector* c_phi;
-} TEOBv4ROMdataDS_coeff;
-
 // Constants if needed
 //static const INT4 n_pars = 5; // dimensionality of the parameter space
 //static const INT4 n_hyp = 7; // number of hyperparameters in GP kernel
@@ -125,8 +118,8 @@ struct tagTEOBv4ROMdataDS_submodel
   gsl_matrix *hyp_phi;         // GP hyperparameters for dephasing
   gsl_matrix *kinv_dot_y_amp;  // kinv_dot_y for log amplitude
   gsl_matrix *kinv_dot_y_phi;  // kinv_dot_y for dephasing
-  // gsl_matrix *B_amp;           // Reduced basis for log amplitude
-  // gsl_matrix *B_phi;           // Reduced basis for dephasing
+  gsl_matrix *B_amp;           // Reduced basis for log amplitude
+  gsl_matrix *B_phi;           // Reduced basis for dephasing
   gsl_matrix *x_train;         // Training points
   gsl_vector *mf_amp;          // location of spline nodes for log amplitude
   gsl_vector *mf_phi;          // location of spline nodes for dephasing
@@ -137,20 +130,6 @@ struct tagTEOBv4ROMdataDS_submodel
   double chi2_bounds[2];       // [chi2_min, chi2_max]
   double lambda1_bounds[2];    // [lambda1_min, lambda1_max]
   double lambda2_bounds[2];    // [lambda2_min, lambda2_max]
-
-  gsl_vector* cvec_amp;      // Flattened amplitude projection coefficients
-  gsl_vector* cvec_phi;      // Flattened phase projection coefficients
-  gsl_matrix *Bamp;          // Reduced SVD basis for amplitude
-  gsl_matrix *Bphi;          // Reduced SVD basis for phase
-  int nk_amp;                // Number frequency points for amplitude
-  int nk_phi;                // Number of frequency points for phase
-  gsl_vector *gA;            // Sparse frequency points for amplitude
-  gsl_vector *gPhi;          // Sparse frequency points for phase
-  gsl_vector *etavec;        // B-spline knots in eta
-  gsl_vector *chi1vec;       // B-spline knots in chi1
-  gsl_vector *chi2vec;       // B-spline knots in chi2
-  int ncx, ncy, ncz;         // Number of points in eta, chi1, chi2
-  double eta_bounds[2];      // [eta_min, eta_max]
 };
 typedef struct tagTEOBv4ROMdataDS_submodel TEOBv4ROMdataDS_submodel;
 
@@ -158,8 +137,6 @@ struct tagTEOBv4ROMdataDS
 {
   UINT4 setup;
   TEOBv4ROMdataDS_submodel* sub1;
-  TEOBv4ROMdataDS_submodel* sub2;
-  TEOBv4ROMdataDS_submodel* sub3;
 };
 typedef struct tagTEOBv4ROMdataDS TEOBv4ROMdataDS;
 
@@ -167,15 +144,10 @@ static TEOBv4ROMdataDS __lalsim_TEOBv4ROMDS_data;
 
 typedef int (*load_dataPtr)(const char*, gsl_vector *, gsl_vector *, gsl_matrix *, gsl_matrix *, gsl_vector *);
 
-typedef struct tagSplineData
-{
-  gsl_bspline_workspace *bwx;
-  gsl_bspline_workspace *bwy;
-  gsl_bspline_workspace *bwz;
-} SplineData;
-
 /**************** Internal functions **********************/
 
+static gsl_vector *gsl_vector_prepend_value(gsl_vector *v, double value);
+
 double kernel(
   gsl_vector *x1,          // array with shape ndim
   gsl_vector *x2,          // array with shape ndim
@@ -197,27 +169,6 @@ UNUSED static bool TEOBv4ROM_IsSetup(void);
 UNUSED static int TEOBv4ROMdataDS_Init(TEOBv4ROMdataDS *romdata, const char dir[]);
 UNUSED static void TEOBv4ROMdataDS_Cleanup(TEOBv4ROMdataDS *romdata);
 
-static int TP_Spline_interpolation_3d(
-  REAL8 eta,                // Input: eta-value for which projection coefficients should be evaluated
-  REAL8 chi1,               // Input: chi1-value for which projection coefficients should be evaluated
-  REAL8 chi2,               // Input: chi2-value for which projection coefficients should be evaluated
-  gsl_vector *cvec_amp,     // Input: data for spline coefficients for amplitude
-  gsl_vector *cvec_phi,     // Input: data for spline coefficients for phase
-//  gsl_vector *cvec_amp_pre, // Input: data for spline coefficients for amplitude prefactor
-  int nk_amp,               // number of SVD-modes == number of basis functions for amplitude
-  int nk_phi,               // number of SVD-modes == number of basis functions for phase
-  int nk_max,               // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
-  int ncx,                  // Number of points in eta  + 2
-  int ncy,                  // Number of points in chi1 + 2
-  int ncz,                  // Number of points in chi2 + 2
-  const double *etavec,     // B-spline knots in eta
-  const double *chi1vec,    // B-spline knots in chi1
-  const double *chi2vec,    // B-spline knots in chi2
-  gsl_vector *c_amp,        // Output: interpolated projection coefficients for amplitude
-  gsl_vector *c_phi         // Output: interpolated projection coefficients for phase
-//  REAL8 *amp_pre            // Output: interpolated amplitude prefactor
-);
-
 static int GPR_evaluation_5D(
   double q,                      // Input: q-value (q >= 1)
   double chi1,                   // Input: chi1-value
@@ -261,79 +212,33 @@ UNUSED static int TEOBv4ROMCore(
   double lambda1,
   double lambda2,
   const REAL8Sequence *freqs, /* Frequency points at which to evaluate the waveform (Hz) */
-  double deltaF,
+  double deltaF
   /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
    * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
    * Then we will use deltaF = 0 to create the frequency series we return. */
-  int nk_max // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
 );
 
-UNUSED static void TEOBv4ROMdataDS_coeff_Init(TEOBv4ROMdataDS_coeff **romdatacoeff, int nk_amp, int nk_phi);
-UNUSED static void TEOBv4ROMdataDS_coeff_Cleanup(TEOBv4ROMdataDS_coeff *romdatacoeff);
-
 static size_t NextPow2(const size_t n);
-UNUSED static void SplineData_Destroy(SplineData *splinedata);
-UNUSED static void SplineData_Init(
-  SplineData **splinedata,
-  int ncx,                // Number of points in eta  + 2
-  int ncy,                // Number of points in chi1 + 2
-  int ncz,                // Number of points in chi2 + 2
-  const double *etavec,   // B-spline knots in eta
-  const double *chi1vec,  // B-spline knots in chi1
-  const double *chi2vec   // B-spline knots in chi2
-);
 
-UNUSED static int TEOBv4ROMTimeFrequencySetup(
-  gsl_spline **spline_phi,                      // phase spline
-  gsl_interp_accel **acc_phi,                   // phase spline accelerator
-  REAL8 *Mf_final,                              // ringdown frequency in Mf
-  REAL8 *Mtot_sec,                              // total mass in seconds
-  REAL8 m1SI,                                   // Mass of companion 1 (kg)
-  REAL8 m2SI,                                   // Mass of companion 2 (kg)
-  REAL8 chi1,                                   // Aligned spin of companion 1
-  REAL8 chi2,                                   // Aligned spin of companion 2
-  REAL8 *Mf_ROM_min,                            // Lowest geometric frequency for ROM
-  REAL8 *Mf_ROM_max                             // Highest geometric frequency for ROM
-);
-
-UNUSED static REAL8 Interpolate_Coefficent_Matrix(
-  gsl_vector *v,
-  REAL8 eta,
-  REAL8 chi,
-  int ncx,
-  int ncy,
-  gsl_bspline_workspace *bwx,
-  gsl_bspline_workspace *bwy
-);
-
-UNUSED static void GlueAmplitude(
-  // INPUTS
-  TEOBv4ROMdataDS_submodel *submodel_lo,
-  TEOBv4ROMdataDS_submodel *submodel_hi,
-  gsl_vector* amp_f_lo,
-  gsl_vector* amp_f_hi,
-  double amp_pre_lo,
-  double amp_pre_hi,
-  const double Mfm,
-  // OUTPUTS
-  gsl_interp_accel **acc_amp,
-  gsl_spline **spline_amp
+static int TaylorF2Phasing(
+  double Mtot,         // Total mass in solar masses
+  double q,            // Mass-ration m1/m2 >= 1
+  double chi1,         // Dimensionless aligned spin of body 1
+  double chi2,         // Dimensionless aligned spin of body 2
+  double lambda1,      // Tidal deformability of body 1
+  double lambda2,      // Tidal deformability of body 2
+  double dquadmon1,    // Self-spin deformation of body 1
+  double dquadmon2,    // Self-spin deformation of body 2
+  gsl_vector *Mfs,     // Input geometric frequencies
+  gsl_vector **PNphase // Output: TaylorF2 phase at frequencies Mfs
 );
 
-UNUSED static void GluePhasing(
-  // INPUTS
-  TEOBv4ROMdataDS_submodel *submodel_lo,
-  TEOBv4ROMdataDS_submodel *submodel_hi,
-  gsl_vector* phi_f_lo,
-  gsl_vector* phi_f_hi,
-  const double Mfm,
-  // OUTPUTS
-  gsl_interp_accel **acc_phi_out,
-  gsl_spline **spline_phi_out
+static int TaylorF2Amplitude1PN(
+  double eta,        // Symmetric mass-ratio
+  gsl_vector *Mfs,   // Input geometric frequencies
+  gsl_vector **PNamp // Output: TaylorF2 amplitude at frequencies Mfs
 );
 
-static gsl_vector *gsl_vector_prepend_value(gsl_vector *v, double value);
-
 /********************* Definitions begin here ********************/
 
 static gsl_vector *gsl_vector_prepend_value(gsl_vector *v, double value) {
@@ -447,7 +352,6 @@ double gp_predict(
   return res;
 }
 
-
 /** Setup TEOBv4ROM model using data files installed in dir
  */
 static int TEOBv4ROM_Init(const char dir[]) {
@@ -455,7 +359,6 @@ static int TEOBv4ROM_Init(const char dir[]) {
     XLALPrintError("Error: TEOBv4ROM data was already set up!");
     XLAL_ERROR(XLAL_EFAILED);
   }
-fprintf(stderr, "In TEOBv4ROM_Init()\n");
   TEOBv4ROMdataDS_Init(&__lalsim_TEOBv4ROMDS_data, dir);
 
   if(__lalsim_TEOBv4ROMDS_data.setup) {
@@ -474,121 +377,6 @@ static bool TEOBv4ROM_IsSetup(void) {
     return false;
 }
 
-// Setup B-spline basis functions for given points
-static void SplineData_Init(
-  SplineData **splinedata,
-  int ncx,                // Number of points in eta  + 2
-  int ncy,                // Number of points in chi1 + 2
-  int ncz,                // Number of points in chi2 + 2
-  const double *etavec,   // B-spline knots in eta
-  const double *chi1vec,  // B-spline knots in chi1
-  const double *chi2vec   // B-spline knots in chi2
-)
-{
-  if(!splinedata) exit(1);
-  if(*splinedata) SplineData_Destroy(*splinedata);
-
-  (*splinedata)=XLALCalloc(1,sizeof(SplineData));
-
-  // Set up B-spline basis for desired knots
-  const size_t nbreak_x = ncx-2;  // must have nbreak = n-2 for cubic splines
-  const size_t nbreak_y = ncy-2;  // must have nbreak = n-2 for cubic splines
-  const size_t nbreak_z = ncz-2;  // must have nbreak = n-2 for cubic splines
-
-  // Allocate a cubic bspline workspace (k = 4)
-  gsl_bspline_workspace *bwx = gsl_bspline_alloc(4, nbreak_x);
-  gsl_bspline_workspace *bwy = gsl_bspline_alloc(4, nbreak_y);
-  gsl_bspline_workspace *bwz = gsl_bspline_alloc(4, nbreak_z);
-
-  // Set breakpoints (and thus knots by hand)
-  gsl_vector *breakpts_x = gsl_vector_alloc(nbreak_x);
-  gsl_vector *breakpts_y = gsl_vector_alloc(nbreak_y);
-  gsl_vector *breakpts_z = gsl_vector_alloc(nbreak_z);
-  for (UINT4 i=0; i<nbreak_x; i++)
-    gsl_vector_set(breakpts_x, i, etavec[i]);
-  for (UINT4 j=0; j<nbreak_y; j++)
-    gsl_vector_set(breakpts_y, j, chi1vec[j]);
-  for (UINT4 k=0; k<nbreak_z; k++)
-    gsl_vector_set(breakpts_z, k, chi2vec[k]);
-
-  gsl_bspline_knots(breakpts_x, bwx);
-  gsl_bspline_knots(breakpts_y, bwy);
-  gsl_bspline_knots(breakpts_z, bwz);
-
-  gsl_vector_free(breakpts_x);
-  gsl_vector_free(breakpts_y);
-  gsl_vector_free(breakpts_z);
-
-  (*splinedata)->bwx=bwx;
-  (*splinedata)->bwy=bwy;
-  (*splinedata)->bwz=bwz;
-}
-
-static void SplineData_Destroy(SplineData *splinedata)
-{
-  if(!splinedata) return;
-  if(splinedata->bwx) gsl_bspline_free(splinedata->bwx);
-  if(splinedata->bwy) gsl_bspline_free(splinedata->bwy);
-  if(splinedata->bwz) gsl_bspline_free(splinedata->bwz);
-  XLALFree(splinedata);
-}
-
-// Interpolate projection coefficients for amplitude and phase over the parameter space (q, chi).
-// The multi-dimensional interpolation is carried out via a tensor product decomposition.
-static int TP_Spline_interpolation_3d(
-  REAL8 eta,                // Input: eta-value for which projection coefficients should be evaluated
-  REAL8 chi1,               // Input: chi1-value for which projection coefficients should be evaluated
-  REAL8 chi2,               // Input: chi2-value for which projection coefficients should be evaluated
-  gsl_vector *cvec_amp,     // Input: data for spline coefficients for amplitude
-  gsl_vector *cvec_phi,     // Input: data for spline coefficients for phase
-  int nk_amp,               // number of SVD-modes == number of basis functions for amplitude
-  int nk_phi,               // number of SVD-modes == number of basis functions for phase
-  int nk_max,               // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
-  int ncx,                  // Number of points in eta  + 2
-  int ncy,                  // Number of points in chi1 + 2
-  int ncz,                  // Number of points in chi2 + 2
-  const double *etavec,     // B-spline knots in eta
-  const double *chi1vec,    // B-spline knots in chi1
-  const double *chi2vec,    // B-spline knots in chi2
-  gsl_vector *c_amp,        // Output: interpolated projection coefficients for amplitude
-  gsl_vector *c_phi         // Output: interpolated projection coefficients for phase
-  ) {
-  if (nk_max != -1) {
-    if (nk_max > nk_amp || nk_max > nk_phi)
-      XLAL_ERROR(XLAL_EDOM, "Truncation parameter nk_max %d must be smaller or equal to nk_amp %d and nk_phi %d", nk_max, nk_amp, nk_phi);
-    else { // truncate SVD modes
-      nk_amp = nk_max;
-      nk_phi = nk_max;
-    }
-  }
-
-  SplineData *splinedata=NULL;
-  SplineData_Init(&splinedata, ncx, ncy, ncz, etavec, chi1vec, chi2vec);
-
-  gsl_bspline_workspace *bwx=splinedata->bwx;
-  gsl_bspline_workspace *bwy=splinedata->bwy;
-  gsl_bspline_workspace *bwz=splinedata->bwz;
-
-  int N = ncx*ncy*ncz;  // Size of the data matrix for one SVD-mode
-  // Evaluate the TP spline for all SVD modes - amplitude
-  for (int k=0; k<nk_amp; k++) { // For each SVD mode
-    gsl_vector v = gsl_vector_subvector(cvec_amp, k*N, N).vector; // Pick out the coefficient matrix corresponding to the k-th SVD mode.
-    REAL8 csum = Interpolate_Coefficent_Tensor(&v, eta, chi1, chi2, ncy, ncz, bwx, bwy, bwz);
-    gsl_vector_set(c_amp, k, csum);
-  }
-
-  // Evaluate the TP spline for all SVD modes - phase
-  for (int k=0; k<nk_phi; k++) {  // For each SVD mode
-    gsl_vector v = gsl_vector_subvector(cvec_phi, k*N, N).vector; // Pick out the coefficient matrix corresponding to the k-th SVD mode.
-    REAL8 csum = Interpolate_Coefficent_Tensor(&v, eta, chi1, chi2, ncy, ncz, bwx, bwy, bwz);
-    gsl_vector_set(c_phi, k, csum);
-  }
-
-  SplineData_Destroy(splinedata);
-
-  return(0);
-}
-
 // Compute amplitude and phase at empirical interpolant nodes from GPRs.
 // This entails interpolation over the 5D parameter space (q, chi1, chi2, lambda1, lambda2).
 static int GPR_evaluation_5D(
@@ -664,48 +452,8 @@ UNUSED static int TEOBv4ROMdataDS_Init_submodel(
   snprintf(path, size, "%s/%s", dir, ROMDataHDF5);
 
   LALH5File *file = XLALH5FileOpen(path, "r");
-  LALH5File *sub = XLALH5GroupOpen(file, grp_name);
-
-  // Read ROM coefficients
-  ReadHDF5RealVectorDataset(sub, "Amp_ciall", & (*submodel)->cvec_amp);
-  ReadHDF5RealVectorDataset(sub, "Phase_ciall", & (*submodel)->cvec_phi);
-
-  // Read ROM basis functions
-  ReadHDF5RealMatrixDataset(sub, "Bamp", & (*submodel)->Bamp);
-  ReadHDF5RealMatrixDataset(sub, "Bphase", & (*submodel)->Bphi);
-
-  // Read sparse frequency points
-  ReadHDF5RealVectorDataset(sub, "Mf_grid_Amp", & (*submodel)->gA);
-  ReadHDF5RealVectorDataset(sub, "Mf_grid_Phi", & (*submodel)->gPhi);
-
-  // Read parameter space nodes
-  ReadHDF5RealVectorDataset(sub, "etavec", & (*submodel)->etavec);
-  ReadHDF5RealVectorDataset(sub, "chi1vec", & (*submodel)->chi1vec);
-  ReadHDF5RealVectorDataset(sub, "chi2vec", & (*submodel)->chi2vec);
-
-  // Initialize other members
-  (*submodel)->nk_amp = (*submodel)->gA->size;
-  (*submodel)->nk_phi = (*submodel)->gPhi->size;
-  (*submodel)->ncx = (*submodel)->etavec->size + 2;
-  (*submodel)->ncy = (*submodel)->chi1vec->size + 2;
-  (*submodel)->ncz = (*submodel)->chi2vec->size + 2;
-
-  // Domain of definition of submodel
-  (*submodel)->eta_bounds[0] = gsl_vector_get((*submodel)->etavec, 0);
-  (*submodel)->eta_bounds[1] = gsl_vector_get((*submodel)->etavec, (*submodel)->etavec->size - 1);
-  (*submodel)->chi1_bounds[0] = gsl_vector_get((*submodel)->chi1vec, 0);
-  (*submodel)->chi1_bounds[1] = gsl_vector_get((*submodel)->chi1vec, (*submodel)->chi1vec->size - 1);
-  (*submodel)->chi2_bounds[0] = gsl_vector_get((*submodel)->chi2vec, 0);
-  (*submodel)->chi2_bounds[1] = gsl_vector_get((*submodel)->chi2vec, (*submodel)->chi2vec->size - 1);
-
-  XLALFree(path);
-  XLALH5FileClose(file);
-
-  // NEW CODE FOR testing TEOBv4
-
-
-  LALH5File *file2 = XLALH5FileOpen("/Users/mpuer/Documents/gpsurrogate/src/TEOB-LAL-implementation/TEOBv4_surrogate.hdf5", "r");
-  LALH5File *root = XLALH5GroupOpen(file2, "/"); // most convenient to open the root once
+  //LALH5File *file = XLALH5FileOpen("/Users/mpuer/Documents/gpsurrogate/src/TEOB-LAL-implementation/TEOBv4_surrogate.hdf5", "r");
+  LALH5File *root = XLALH5GroupOpen(file, "/");
 
   //////////////////////////////////////////////////////////////////////////////
   // load everything we need
@@ -717,10 +465,6 @@ UNUSED static int TEOBv4ROMdataDS_Init_submodel(
   ReadHDF5RealMatrixDataset(root, "kinv_dot_y_amp", & (*submodel)->kinv_dot_y_amp);
   ReadHDF5RealMatrixDataset(root, "kinv_dot_y_phi", & (*submodel)->kinv_dot_y_phi);
 
-  // Reduced bases
-  // ReadHDF5RealMatrixDataset(root, "B_amp", & (*submodel)->B_amp);
-  // ReadHDF5RealMatrixDataset(root, "B_phi", & (*submodel)->B_phi);
-
   // Training points
   ReadHDF5RealMatrixDataset(root, "x_train", & (*submodel)->x_train);
 
@@ -745,18 +489,14 @@ UNUSED static int TEOBv4ROMdataDS_Init_submodel(
   // FIXME: check consistency of sizes against constants defined above
 
   // Prepend the point [mf_amp[0], 0] to the phase nodes
-fprintf(stderr, "Before len(mf_phi) = %zu\n", (*submodel)->mf_phi->size);
+  fprintf(stderr, "Before len(mf_phi) = %zu\n", (*submodel)->mf_phi->size);
   double mf_min = gsl_vector_get( (*submodel)->mf_amp, 0); // Follow definition of mf_a in GPSplineSurrogate constructor
   gsl_vector *phi_nodes = gsl_vector_prepend_value((*submodel)->mf_phi, mf_min);
   (*submodel)->mf_phi = phi_nodes;
-fprintf(stderr, "After len(mf_phi) = %zu\n", (*submodel)->mf_phi->size);
-
-  // cleanup
-
-  XLALH5FileClose(file2);
-
-  // END NEW CODE
+  fprintf(stderr, "After len(mf_phi) = %zu\n", (*submodel)->mf_phi->size);
 
+  XLALFree(path);
+  XLALH5FileClose(file);
   ret = XLAL_SUCCESS;
 #else
   XLAL_ERROR(XLAL_EFAILED, "HDF5 support not enabled");
@@ -767,24 +507,10 @@ fprintf(stderr, "After len(mf_phi) = %zu\n", (*submodel)->mf_phi->size);
 
 /* Deallocate contents of the given TEOBv4ROMdataDS_submodel structure */
 static void TEOBv4ROMdataDS_Cleanup_submodel(TEOBv4ROMdataDS_submodel *submodel) {
-  // FIXME: remove these
-  if(submodel->cvec_amp) gsl_vector_free(submodel->cvec_amp);
-  if(submodel->cvec_phi) gsl_vector_free(submodel->cvec_phi);
-  if(submodel->Bamp) gsl_matrix_free(submodel->Bamp);
-  if(submodel->Bphi) gsl_matrix_free(submodel->Bphi);
-  if(submodel->gA)   gsl_vector_free(submodel->gA);
-  if(submodel->gPhi) gsl_vector_free(submodel->gPhi);
-  if(submodel->etavec)  gsl_vector_free(submodel->etavec);
-  if(submodel->chi1vec) gsl_vector_free(submodel->chi1vec);
-  if(submodel->chi2vec) gsl_vector_free(submodel->chi2vec);
-
   if(submodel->hyp_amp) gsl_matrix_free(submodel->hyp_amp);
   if(submodel->hyp_phi) gsl_matrix_free(submodel->hyp_phi);
   if(submodel->kinv_dot_y_amp) gsl_matrix_free(submodel->kinv_dot_y_amp);
   if(submodel->kinv_dot_y_phi) gsl_matrix_free(submodel->kinv_dot_y_phi);
-  // if(submodel->B_amp) gsl_matrix_free(submodel->B_amp);
-  // if(submodel->B_phi) gsl_matrix_free(submodel->B_phi);
-
   if(submodel->x_train) gsl_matrix_free(submodel->x_train);
   if(submodel->mf_amp) gsl_vector_free(submodel->mf_amp);
   if(submodel->mf_phi) gsl_vector_free(submodel->mf_phi);
@@ -802,7 +528,7 @@ int TEOBv4ROMdataDS_Init(
     XLALPrintError("WARNING: You tried to setup the TEOBv4ROM model that was already initialised. Ignoring\n");
     return (XLAL_FAILURE);
   }
-fprintf(stderr, "In TEOBv4ROMdataDS_Init()\n");
+
 #ifdef LAL_HDF5_ENABLED
   // First, check we got the correct version number
   size_t size = strlen(dir) + strlen(ROMDataHDF5) + 2;
@@ -810,25 +536,20 @@ fprintf(stderr, "In TEOBv4ROMdataDS_Init()\n");
   snprintf(path, size, "%s/%s", dir, ROMDataHDF5);
   LALH5File *file = XLALH5FileOpen(path, "r");
 
-  XLALPrintInfo("ROM metadata\n============\n");
-  PrintInfoStringAttribute(file, "Email");
-  PrintInfoStringAttribute(file, "Description");
-  ret = ROM_check_version_number(file, ROMDataHDF5_VERSION_MAJOR,
-                                 ROMDataHDF5_VERSION_MINOR,
-                                 ROMDataHDF5_VERSION_MICRO);
+// FIXME: uncomment this after fixing the attributes in the HDF5 file
+  // XLALPrintInfo("ROM metadata\n============\n");
+  // PrintInfoStringAttribute(file, "Email");
+  // PrintInfoStringAttribute(file, "Description");
+  // ret = ROM_check_version_number(file, ROMDataHDF5_VERSION_MAJOR,
+  //                                ROMDataHDF5_VERSION_MINOR,
+  //                                ROMDataHDF5_VERSION_MICRO);
 
   XLALFree(path);
   XLALH5FileClose(file);
-fprintf(stderr, "In TEOBv4ROMdataDS_Init(): read metadata\n");
-  ret |= TEOBv4ROMdataDS_Init_submodel(&(romdata)->sub1, dir, "sub1");
-  if (ret==XLAL_SUCCESS) XLALPrintInfo("%s : submodel 1 loaded successfully.\n", __func__);
 
-  ret |= TEOBv4ROMdataDS_Init_submodel(&(romdata)->sub2, dir, "sub2");
-  if (ret==XLAL_SUCCESS) XLALPrintInfo("%s : submodel 2 loaded successfully.\n", __func__);
+  ret = TEOBv4ROMdataDS_Init_submodel(&(romdata)->sub1, dir, "sub1");
+  if (ret==XLAL_SUCCESS) XLALPrintInfo("%s : submodel 1 loaded successfully.\n", __func__);
 
-  ret |= TEOBv4ROMdataDS_Init_submodel(&(romdata)->sub3, dir, "sub3");
-  if (ret==XLAL_SUCCESS) XLALPrintInfo("%s : submodel 3 loaded successfully.\n", __func__);
-fprintf(stderr, "In TEOBv4ROMdataDS_Init(): read submodels: %d\n", ret);
   if(XLAL_SUCCESS==ret)
     romdata->setup=1;
   else
@@ -845,232 +566,25 @@ static void TEOBv4ROMdataDS_Cleanup(TEOBv4ROMdataDS *romdata) {
   TEOBv4ROMdataDS_Cleanup_submodel((romdata)->sub1);
   XLALFree((romdata)->sub1);
   (romdata)->sub1 = NULL;
-  TEOBv4ROMdataDS_Cleanup_submodel((romdata)->sub2);
-  XLALFree((romdata)->sub2);
-  (romdata)->sub2 = NULL;
-  TEOBv4ROMdataDS_Cleanup_submodel((romdata)->sub3);
-  XLALFree((romdata)->sub3);
-  (romdata)->sub3 = NULL;
   romdata->setup=0;
 }
 
-/* Structure for internal use */
-static void TEOBv4ROMdataDS_coeff_Init(TEOBv4ROMdataDS_coeff **romdatacoeff, int nk_amp, int nk_phi) {
-  if(!romdatacoeff) exit(1);
-  /* Create storage for structures */
-  if(!*romdatacoeff)
-    *romdatacoeff=XLALCalloc(1,sizeof(TEOBv4ROMdataDS_coeff));
-  else
-    TEOBv4ROMdataDS_coeff_Cleanup(*romdatacoeff);
-
-  (*romdatacoeff)->c_amp = gsl_vector_alloc(nk_amp);
-  (*romdatacoeff)->c_phi = gsl_vector_alloc(nk_phi);
-}
-
-/* Deallocate contents of the given TEOBv4ROMdataDS_coeff structure */
-static void TEOBv4ROMdataDS_coeff_Cleanup(TEOBv4ROMdataDS_coeff *romdatacoeff) {
-  if(romdatacoeff->c_amp) gsl_vector_free(romdatacoeff->c_amp);
-  if(romdatacoeff->c_phi) gsl_vector_free(romdatacoeff->c_phi);
-  XLALFree(romdatacoeff);
-}
-
 /* Return the closest higher power of 2  */
 // Note: NextPow(2^k) = 2^k for integer values k.
 static size_t NextPow2(const size_t n) {
   return 1 << (size_t) ceil(log2(n));
 }
 
-static void GlueAmplitude(
-  // INPUTS
-  TEOBv4ROMdataDS_submodel *submodel_lo,
-  TEOBv4ROMdataDS_submodel *submodel_hi,
-  gsl_vector* amp_f_lo,
-  gsl_vector* amp_f_hi,
-  // amp_pre_* can be set to 1 if not using amplitude prefactors
-  double amp_pre_lo,
-  double amp_pre_hi,
-  const double Mfm,
-  // OUTPUTS
-  gsl_interp_accel **acc_amp,
-  gsl_spline **spline_amp
-) {
-  // First need to find overlaping frequency interval
-  int jA_lo;
-  // Find index so that Mf < Mfm
-  for (jA_lo=0; jA_lo < submodel_lo->nk_amp; jA_lo++) {
-    if (gsl_vector_get(submodel_lo->gA, jA_lo) > Mfm) {
-      jA_lo--;
-      break;
-    }
-  }
-
-  int jA_hi;
-  // Find index so that Mf > Mfm
-  for (jA_hi=0; jA_hi < submodel_hi->nk_amp; jA_hi++)
-    if (gsl_vector_get(submodel_hi->gA, jA_hi) > Mfm)
-      break;
-
-  int nA = 1 + jA_lo + (submodel_hi->nk_amp - jA_hi); // length of the union of frequency points of the low and high frequency models glued at MfM
-
-  gsl_vector *gAU = gsl_vector_alloc(nA); // glued frequency grid
-  gsl_vector *amp_f = gsl_vector_alloc(nA); // amplitude on glued frequency grid
-  // Note: We don't interpolate the amplitude, but this may already be smooth enough for practical purposes.
-  // To improve this we would evaluate both amplitue splines times the prefactor at the matching frequency and correct with the ratio, so we are C^0.
-  for (int i=0; i<=jA_lo; i++) {
-    gsl_vector_set(gAU, i, gsl_vector_get(submodel_lo->gA, i));
-    double A = amp_pre_lo * gsl_vector_get(amp_f_lo, i);
-    gsl_vector_set(amp_f, i, A);
-  }
-
-  for (int i=jA_lo+1; i<nA; i++) {
-    int k = jA_hi - (jA_lo+1) + i;
-    gsl_vector_set(gAU, i, gsl_vector_get(submodel_hi->gA, k));
-    double A = amp_pre_hi * gsl_vector_get(amp_f_hi, k);
-    gsl_vector_set(amp_f, i, A);
-  }
-
-  // Setup 1d splines in frequency from glued amplitude grids & data
-  *acc_amp = gsl_interp_accel_alloc();
-  *spline_amp = gsl_spline_alloc(gsl_interp_cspline, nA);
-  //gsl_spline_init(spline_amp, gAU->data, gsl_vector_const_ptr(amp_f,0), nA);
-  gsl_spline_init(*spline_amp, gsl_vector_const_ptr(gAU,0),
-                  gsl_vector_const_ptr(amp_f,0), nA);
-
-  gsl_vector_free(gAU);
-  gsl_vector_free(amp_f);
-  gsl_vector_free(amp_f_lo);
-  gsl_vector_free(amp_f_hi);
-}
-
-// Glue phasing in frequency to C^1 smoothness
-static void GluePhasing(
-  // INPUTS
-  TEOBv4ROMdataDS_submodel *submodel_lo,
-  TEOBv4ROMdataDS_submodel *submodel_hi,
-  gsl_vector* phi_f_lo,
-  gsl_vector* phi_f_hi,
-  const double Mfm,
-  // OUTPUTS
-  gsl_interp_accel **acc_phi,
-  gsl_spline **spline_phi
-) {
-  // First need to find overlaping frequency interval
-  int jP_lo;
-  // Find index so that Mf < Mfm
-  for (jP_lo=0; jP_lo < submodel_lo->nk_phi; jP_lo++) {
-    if (gsl_vector_get(submodel_lo->gPhi, jP_lo) > Mfm) {
-      jP_lo--;
-      break;
-    }
-  }
-
-  int jP_hi;
-  // Find index so that Mf > Mfm
-  for (jP_hi=0; jP_hi < submodel_hi->nk_phi; jP_hi++)
-    if (gsl_vector_get(submodel_hi->gPhi, jP_hi) > Mfm)
-      break;
-
-  int nP = 1 + jP_lo + (submodel_hi->nk_phi - jP_hi); // length of the union of frequency points of the low and high frequency models glued at MfM
-  gsl_vector *gPU = gsl_vector_alloc(nP); // glued frequency grid
-  gsl_vector *phi_f = gsl_vector_alloc(nP); // phase on glued frequency grid
-  // We need to do a bit more work to glue the phase with C^1 smoothness
-  for (int i=0; i<=jP_lo; i++) {
-    gsl_vector_set(gPU, i, gsl_vector_get(submodel_lo->gPhi, i));
-    double P = gsl_vector_get(phi_f_lo, i);
-    gsl_vector_set(phi_f, i, P);
-  }
-
-  for (int i=jP_lo+1; i<nP; i++) {
-    int k = jP_hi - (jP_lo+1) + i;
-    gsl_vector_set(gPU, i, gsl_vector_get(submodel_hi->gPhi, k));
-    double P = gsl_vector_get(phi_f_hi, k);
-    gsl_vector_set(phi_f, i, P);
-  }
-
-  // Set up phase data across the gluing frequency Mfm
-  // We need to set up a spline for the low frequency model and evaluate at the designated points for the high frequency model so that we work with the *same* frequeny interval!
-
-  // We could optimize this further by not constructing the whole spline for
-  // submodel_lo, but this may be insignificant since the number of points is small anyway.
-  gsl_interp_accel *acc_phi_lo = gsl_interp_accel_alloc();
-  gsl_spline *spline_phi_lo = gsl_spline_alloc(gsl_interp_cspline, submodel_lo->nk_phi);
-  gsl_spline_init(spline_phi_lo, gsl_vector_const_ptr(submodel_lo->gPhi,0),
-                  gsl_vector_const_ptr(phi_f_lo,0), submodel_lo->nk_phi);
-
-  const int nn = 15;
-  gsl_vector_const_view gP_hi_data = gsl_vector_const_subvector(submodel_hi->gPhi, jP_hi - nn, 2*nn+1);
-  gsl_vector_const_view P_hi_data = gsl_vector_const_subvector(phi_f_hi, jP_hi - nn, 2*nn+1);
-  gsl_vector *P_lo_data = gsl_vector_alloc(2*nn+1);
-  for (int i=0; i<2*nn+1; i++) {
-    double P = gsl_spline_eval(spline_phi_lo, gsl_vector_get(&gP_hi_data.vector, i), acc_phi_lo);
-    gsl_vector_set(P_lo_data, i, P);
-  }
-
-  // Fit phase data to cubic polynomial in frequency
-  gsl_vector *cP_lo = Fit_cubic(&gP_hi_data.vector, P_lo_data);
-  gsl_vector *cP_hi = Fit_cubic(&gP_hi_data.vector, &P_hi_data.vector);
-
-  double P_lo_derivs[2];
-  double P_hi_derivs[2];
-  gsl_poly_eval_derivs(cP_lo->data, 4, Mfm, P_lo_derivs, 2);
-  gsl_poly_eval_derivs(cP_hi->data, 4, Mfm, P_hi_derivs, 2);
-
-  double delta_omega = P_hi_derivs[1] - P_lo_derivs[1];
-  double delta_phi   = P_hi_derivs[0] - P_lo_derivs[0] - delta_omega * Mfm;
-
-  for (int i=jP_lo+1; i<nP; i++) {
-    int k = jP_hi - (jP_lo+1) + i;
-    double f = gsl_vector_get(submodel_hi->gPhi, k);
-    gsl_vector_set(gPU, i, f);
-    double P = gsl_vector_get(phi_f_hi, k) - delta_omega * f - delta_phi; // Now correct phase of high frequency submodel
-    gsl_vector_set(phi_f, i, P);
-  }
-
-  // free some vectors
-  gsl_vector_free(P_lo_data);
-  gsl_vector_free(cP_lo);
-  gsl_vector_free(cP_hi);
-  gsl_vector_free(phi_f_lo);
-  gsl_vector_free(phi_f_hi);
-
-  // Setup 1d splines in frequency from glued phase grids & data
-  *acc_phi = gsl_interp_accel_alloc();
-  *spline_phi = gsl_spline_alloc(gsl_interp_cspline, nP);
-  //gsl_spline_init(spline_phi, gPU->data, gsl_vector_const_ptr(phi_f,0), nP);
-  gsl_spline_init(*spline_phi, gsl_vector_const_ptr(gPU,0),
-                  gsl_vector_const_ptr(phi_f,0), nP);
-
-  /**** Finished gluing ****/
-
-  gsl_vector_free(phi_f);
-  gsl_vector_free(gPU);
-  gsl_spline_free(spline_phi_lo);
-  gsl_interp_accel_free(acc_phi_lo);
-}
-
-static int TaylorF2Phasing(
-  double Mtot,
-  double q,
-  double chi1,
-  double chi2,
-  double lambda1,   // tidal deformability of body 1
-  double lambda2,   // tidal deformability of body 2
-  double dquadmon1, // self-spin deformation of body 1
-  double dquadmon2, // self-spin deformation of body 2
-  gsl_vector *Mfs,
-  gsl_vector **PNphase // Output: TaylorF2 phase at frequencies Mfs
-);
-
 static int TaylorF2Phasing(
-  double Mtot,
-  double q,
-  double chi1,
-  double chi2,
-  double lambda1,   // tidal deformability of body 1
-  double lambda2,   // tidal deformability of body 2
-  double dquadmon1, // self-spin deformation of body 1
-  double dquadmon2, // self-spin deformation of body 2
-  gsl_vector *Mfs,
+  double Mtot,         // Total mass in solar masses
+  double q,            // Mass-ration m1/m2 >= 1
+  double chi1,         // Dimensionless aligned spin of body 1
+  double chi2,         // Dimensionless aligned spin of body 2
+  double lambda1,      // Tidal deformability of body 1
+  double lambda2,      // Tidal deformability of body 2
+  double dquadmon1,    // Self-spin deformation of body 1
+  double dquadmon2,    // Self-spin deformation of body 2
+  gsl_vector *Mfs,     // Input geometric frequencies
   gsl_vector **PNphase // Output: TaylorF2 phase at frequencies Mfs
 ) {
   XLAL_CHECK(PNphase != NULL, XLAL_EFAULT);
@@ -1087,7 +601,7 @@ static int TaylorF2Phasing(
   // We add the terms after the XLALSimInspiralTaylorF2AlignedPhasing() call below to the structure of PN coefficients.
 
   // FIXME: We should be able to switch on quadrupole-monopole terms (self-spin deformation of the two bodies)
-  // from TaylorF2; later these can be replaced with EOB as well. Just add a switch for now.
+  // from TaylorF2; later these can be replaced with a new TEOB surrogate as well. Just add a switch for now.
   if ((dquadmon1 > 0) || (dquadmon2 > 0)) {
     fprintf(stderr, "Using quadrupole-monopole terms from PN.\n");
     XLALSimInspiralWaveformParamsInsertdQuadMon1(extraParams, dquadmon1);
@@ -1108,10 +622,6 @@ static int TaylorF2Phasing(
   pn->v[12] = pn->v[0] * ( lambda1 * XLALSimInspiralTaylorF2Phasing_12PNTidalCoeff(m1OverM)
                          + lambda2 * XLALSimInspiralTaylorF2Phasing_12PNTidalCoeff(m2OverM) );
 
-  // Total amplitude and phase (PN with added surrogate corrections)
-  //gsl_vector *amp_at_nodes = gsl_vector_alloc(N_amp);
-  //gsl_vector *phi_at_nodes = gsl_vector_alloc(N_phi);
-
 // fprintf(stderr, "pn->v: %g %g %g %g %g %g %g %g \n", pn->v[7], pn->v[6], pn->v[5], pn->v[4], pn->v[3], pn->v[2], pn->v[1], pn->v[0]);
 // fprintf(stderr, "pn->vlogv: %g %g\n", pn->vlogv[6], pn->vlogv[5]);
 
@@ -1168,18 +678,12 @@ static int TaylorF2Phasing(
   return XLAL_SUCCESS;
 }
 
-static int TaylorF2Amplitude1PN(
-  double eta,        // Symmetric mass-ratio
-  gsl_vector *Mfs,   // Geometric frequency
-  gsl_vector **PNamp // Output: TaylorF2 amplitude at frequencies Mfs
-);
-
 // 1PN point-particle amplitude.
 // Expression from Eq. (6.10) of arXiv:0810.5336.
 // !!! This is technically wrong since you have a x**2 term (need to re-expand). !!!
 static int TaylorF2Amplitude1PN(
   double eta,        // Symmetric mass-ratio
-  gsl_vector *Mfs,   // Geometric frequency
+  gsl_vector *Mfs,   // Input geometric frequencies
   gsl_vector **PNamp // Output: TaylorF2 amplitude at frequencies Mfs
 ) {
   XLAL_CHECK(PNamp != NULL, XLAL_EFAULT);
@@ -1220,11 +724,10 @@ static int TEOBv4ROMCore(
   double lambda1,
   double lambda2,
   const REAL8Sequence *freqs_in, /* Frequency points at which to evaluate the waveform (Hz) */
-  double deltaF,
+  double deltaF
   /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
    * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
    * Then we will use deltaF = 0 to create the frequency series we return. */
-  int nk_max // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
   )
 {
   /* Check output arrays */
@@ -1264,18 +767,9 @@ static int TEOBv4ROMCore(
     XLAL_ERROR( XLAL_EDOM );
   }
 
-  /* We always need to glue two submodels together for this ROM */
-  TEOBv4ROMdataDS_submodel *submodel_hi; // high frequency ROM
-  TEOBv4ROMdataDS_submodel *submodel_lo; // low frequency ROM
+  TEOBv4ROMdataDS_submodel *submodel_lo; // FIXME: rename submodel_lo to model
   submodel_lo = romdata->sub1;
 
-  /* Select high frequency ROM submodel */
-  if (chi1 < romdata->sub3->chi1_bounds[0] || eta > romdata->sub3->eta_bounds[1]) // only check the two conditions that apply for this ROM; could be more general, but slower
-    submodel_hi = romdata->sub2;
-  else
-    submodel_hi = romdata->sub3;
-
-
   /* Find frequency bounds */
   if (!freqs_in) XLAL_ERROR(XLAL_EFAULT);
   double fLow  = freqs_in->data[0];
@@ -1285,12 +779,15 @@ static int TEOBv4ROMCore(
     fRef=fLow;
 
   /* Convert to geometric units for frequency */
+  int N_amp = submodel_lo->mf_amp->size;
+  int N_phi = submodel_lo->mf_phi->size;
+
   // lowest allowed geometric frequency for ROM
-  double Mf_ROM_min = fmax(gsl_vector_get(submodel_lo->gA, 0),
-                           gsl_vector_get(submodel_lo->gPhi,0));
+  double Mf_ROM_min = fmax(gsl_vector_get(submodel_lo->mf_amp, 0),
+                           gsl_vector_get(submodel_lo->mf_phi,0));
   // highest allowed geometric frequency for ROM
-  double Mf_ROM_max = fmin(gsl_vector_get(submodel_hi->gA, submodel_hi->nk_amp-1),
-                           gsl_vector_get(submodel_hi->gPhi, submodel_hi->nk_phi-1));
+  double Mf_ROM_max = fmin(gsl_vector_get(submodel_lo->mf_amp, N_amp-1),
+                           gsl_vector_get(submodel_lo->mf_phi, N_phi-1));
   double fLow_geom = fLow * Mtot_sec;
   double fHigh_geom = fHigh * Mtot_sec;
   double fRef_geom = fRef * Mtot_sec;
@@ -1317,19 +814,9 @@ static int TEOBv4ROMCore(
   if (Mtot_sec/LAL_MTSUN_SI > 500.0)
     XLALPrintWarning("Total mass=%gMsun > 500Msun. TEOBv4ROM disagrees with SEOBNRv4 for high total masses.\n", Mtot_sec/LAL_MTSUN_SI);
 
-  /* Internal storage for waveform coefficiencts */
-  TEOBv4ROMdataDS_coeff *romdata_coeff_lo=NULL;
-  TEOBv4ROMdataDS_coeff *romdata_coeff_hi=NULL;
-  TEOBv4ROMdataDS_coeff_Init(&romdata_coeff_lo, submodel_lo->nk_amp, submodel_lo->nk_phi);
-  TEOBv4ROMdataDS_coeff_Init(&romdata_coeff_hi, submodel_hi->nk_amp, submodel_hi->nk_phi);
-  REAL8 amp_pre_lo = 1.0; // unused here
-  REAL8 amp_pre_hi = 1.0;
 
-
-  // TODO: Call GPR instead for log amplitude and dephasing
+  // Evaluate GPR for log amplitude and dephasing
   double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
-  int N_amp = submodel_lo->mf_amp->size;
-  int N_phi = submodel_lo->mf_phi->size; // should already be corrected
   gsl_vector *sur_amp_at_nodes = gsl_vector_alloc(N_amp);
   gsl_vector *sur_phi_at_nodes_tmp = gsl_vector_alloc(N_phi - 1); // Will prepend a point below
   assert(N_amp == N_phi); // FIXME: is it safe to assume this?
@@ -1345,6 +832,11 @@ static int TEOBv4ROMCore(
     sur_phi_at_nodes_tmp
   );
 
+  if(retcode!=0) {
+    //TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_lo); /// FIXME: change to clean the data for the GPR model
+    XLAL_ERROR(retcode);
+  }
+
   for (int i=0; i<N_phi-1; i++)
     fprintf(stderr, "mf_phi, phi_at_nodes [%d] = (%g, %g)\n", i,
     gsl_vector_get(submodel_lo->mf_phi, i),
@@ -1361,97 +853,6 @@ fprintf(stderr, "N_amp, N_phi = %d, %d\n", N_amp, N_phi);
     gsl_vector_get(sur_phi_at_nodes, i));
 
 
-
-
-  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
-  retcode=TP_Spline_interpolation_3d(
-    eta,                          // Input: eta-value for which projection coefficients should be evaluated
-    chi1,                         // Input: chi1-value for which projection coefficients should be evaluated
-    chi2,                         // Input: chi2-value for which projection coefficients should be evaluated
-    submodel_lo->cvec_amp,        // Input: data for spline coefficients for amplitude
-    submodel_lo->cvec_phi,        // Input: data for spline coefficients for phase
-    submodel_lo->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
-    submodel_lo->nk_phi,          // number of SVD-modes == number of basis functions for phase
-    nk_max,                       // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
-    submodel_lo->ncx,             // Number of points in eta  + 2
-    submodel_lo->ncy,             // Number of points in chi1 + 2
-    submodel_lo->ncz,             // Number of points in chi2 + 2
-    gsl_vector_const_ptr(submodel_lo->etavec, 0),          // B-spline knots in eta
-    gsl_vector_const_ptr(submodel_lo->chi1vec, 0),        // B-spline knots in chi1
-    gsl_vector_const_ptr(submodel_lo->chi2vec, 0),        // B-spline knots in chi2
-    romdata_coeff_lo->c_amp,      // Output: interpolated projection coefficients for amplitude
-    romdata_coeff_lo->c_phi       // Output: interpolated projection coefficients for phase
-  );
-
-  if(retcode!=0) {
-    TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_lo);
-    XLAL_ERROR(retcode);
-  }
-
-  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
-  retcode=TP_Spline_interpolation_3d(
-    eta,                          // Input: eta-value for which projection coefficients should be evaluated
-    chi1,                         // Input: chi1-value for which projection coefficients should be evaluated
-    chi2,                         // Input: chi2-value for which projection coefficients should be evaluated
-    submodel_hi->cvec_amp,        // Input: data for spline coefficients for amplitude
-    submodel_hi->cvec_phi,        // Input: data for spline coefficients for phase
-    submodel_hi->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
-    submodel_hi->nk_phi,          // number of SVD-modes == number of basis functions for phase
-    nk_max,                       // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
-    submodel_hi->ncx,             // Number of points in eta  + 2
-    submodel_hi->ncy,             // Number of points in chi1 + 2
-    submodel_hi->ncz,             // Number of points in chi2 + 2
-    gsl_vector_const_ptr(submodel_hi->etavec, 0),         // B-spline knots in eta
-    gsl_vector_const_ptr(submodel_hi->chi1vec, 0),        // B-spline knots in chi1
-    gsl_vector_const_ptr(submodel_hi->chi2vec, 0),        // B-spline knots in chi2
-    romdata_coeff_hi->c_amp,      // Output: interpolated projection coefficients for amplitude
-    romdata_coeff_hi->c_phi       // Output: interpolated projection coefficients for phase
-  );
-
-  if(retcode!=0) {
-    TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_hi);
-    XLAL_ERROR(retcode);
-  }
-
-
-  // Compute function values of amplitude an phase on sparse frequency points by evaluating matrix vector products
-  // amp_pts = B_A^T . c_A
-  // phi_pts = B_phi^T . c_phi
-  gsl_vector* amp_f_lo = gsl_vector_alloc(submodel_lo->nk_amp);
-  gsl_vector* phi_f_lo = gsl_vector_alloc(submodel_lo->nk_phi);
-  gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->Bamp, romdata_coeff_lo->c_amp, 0.0, amp_f_lo);
-  gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->Bphi, romdata_coeff_lo->c_phi, 0.0, phi_f_lo);
-
-  gsl_vector* amp_f_hi = gsl_vector_alloc(submodel_hi->nk_amp);
-  gsl_vector* phi_f_hi = gsl_vector_alloc(submodel_hi->nk_phi);
-  gsl_blas_dgemv(CblasTrans, 1.0, submodel_hi->Bamp, romdata_coeff_hi->c_amp, 0.0, amp_f_hi);
-  gsl_blas_dgemv(CblasTrans, 1.0, submodel_hi->Bphi, romdata_coeff_hi->c_phi, 0.0, phi_f_hi);
-
-  const double Mfm = 0.01; // Gluing frequency: the low and high frequency ROMs overlap here; this is used both for amplitude and phase.
-
-
-
-  // Evaluate ln amplitude and dephasing
-  // int len = (submodel_lo->B_amp)->size2; // FIXME: use a constant instead
-  // gsl_vector* amp_f = gsl_vector_alloc(len);
-  // gsl_vector* phi_f = gsl_vector_alloc(len);
-  // // THIS is no longer needed
-  // gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->B_amp, amp_at_EI_nodes, 0.0, amp_f);
-  // gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->B_phi, phi_at_EI_nodes, 0.0, phi_f);
-
-  fprintf(stderr, "\namp_at_nodes:");
-  gsl_vector_fprintf(stderr, sur_amp_at_nodes, "%.15g");
-  fprintf(stderr, "\nphi_at_nodes:");
-  gsl_vector_fprintf(stderr, sur_phi_at_nodes, "%.15g");
-
-// FIXME:
-//   * evaluate TF2 basemodel on same frequencies
-//   * add amplitude and phase correction
-//   * then spline them (is that OK, or do we have to spline the correction and TF2 first??)
-
-  // TODO: evaluate hardcoded TF2 and reconstruct waveform
-  // fprintf(stderr, "%zu %zu %zu\n", amp_at_EI_nodes->size, (submodel_lo->B_amp)->size1, (submodel_lo->B_amp)->size2);
-
 double dquadmon1 = 0.0; // FIXME
 double dquadmon2 = 0.0;
 gsl_vector *PN_phi_at_nodes = NULL;
@@ -1461,7 +862,6 @@ fprintf(stderr, "\nphiPN_at_nodes:");
 gsl_vector_fprintf(stderr, PN_phi_at_nodes, "%.15g");
 
 
-
 // FIXME: copy submodel_lo->mf_phi to a dedicated vector
 gsl_vector *PN_amp_at_nodes = NULL;
 TaylorF2Amplitude1PN(eta, submodel_lo->mf_phi, &PN_amp_at_nodes); // FIXME: should input mf_amp unless it is the same as mf_phi
@@ -1472,16 +872,16 @@ gsl_vector_fprintf(stderr, PN_amp_at_nodes, "%.15g");
 
 
 // Setup 1d splines in frequency
-gsl_interp_accel *acc_phiNEW = gsl_interp_accel_alloc();
-gsl_spline *spline_phiNEW = gsl_spline_alloc(gsl_interp_cspline, N_phi);
+gsl_interp_accel *acc_phi = gsl_interp_accel_alloc();
+gsl_spline *spline_phi = gsl_spline_alloc(gsl_interp_cspline, N_phi);
 gsl_vector_add(sur_phi_at_nodes, PN_phi_at_nodes); // stores result in sur_phi_at_nodes
-gsl_spline_init(spline_phiNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0),
+gsl_spline_init(spline_phi, gsl_vector_const_ptr(submodel_lo->mf_phi, 0),
                 gsl_vector_const_ptr(sur_phi_at_nodes, 0), N_phi);
 
 
 
-gsl_interp_accel *acc_ampNEW = gsl_interp_accel_alloc();
-gsl_spline *spline_ampNEW = gsl_spline_alloc(gsl_interp_cspline, N_amp);
+gsl_interp_accel *acc_amp = gsl_interp_accel_alloc();
+gsl_spline *spline_amp = gsl_spline_alloc(gsl_interp_cspline, N_amp);
 // Compute amplitude = PN_amplitude * exp(surrogate_amplitude)
 gsl_vector *spline_amp_values = gsl_vector_alloc(N_amp);
 for (int i=0; i<N_amp; i++) {
@@ -1489,70 +889,13 @@ for (int i=0; i<N_amp; i++) {
   gsl_vector_set(spline_amp_values, i, amp_i);
 }
 
-gsl_spline_init(spline_ampNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), // FIXME: should input mf_amp unless it is the same as mf_phi
+gsl_spline_init(spline_amp, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), // FIXME: should input mf_amp unless it is the same as mf_phi
                 gsl_vector_const_ptr(spline_amp_values, 0), N_amp);
 
 
 
 
 
-  // TODO: splines for amp, phi
-  // FIXME: deallocate all amp, phi variables: PN, surrogate corrections
-
-  // // See LALSimInspiralPNCoefficients.c:XLALSimInspiralPNPhasing_F2()
-  // pn->v[5], ....
-
-  // or get complete TF2 waveform
-  // FIXME: check units: f, m
-  // FIXME: destroy hptilde_TF2 after using it or use hptilde variable
-  // double m1_SI = Mtot * q/(1.0+q) * LAL_MSUN_SI;
-  // double m2_SI = Mtot * 1.0/(1.0+q) * LAL_MSUN_SI;
-  // // COMPLEX16FrequencySeries **hptilde_TF2 = NULL;
-  // LALDict *LALparams = NULL;
-  // XLALSimInspiralTaylorF2(hptilde_TF2, phiRef, deltaF, m1_SI, m2_SI, chi1, chi2, fLow, fHigh, fRef,
-  // distance, LALparams);
-
-  // phasing
-  // FIXME: call XLALSimInspiralTaylorF2AlignedPhasing() to get the point-particle phasing in a structure
-
-
-  // FIXME: reimplement these functions since they are static; better: make them XLAL
-  // static REAL8 UNUSED
-  // XLALSimInspiralTaylorF2Phasing_10PNTidalCoeff(
-  // 	REAL8 mByM /**< ratio of object mass to total mass */
-  //     )
-  // {
-  //   return (-288. + 264.*mByM)*mByM*mByM*mByM*mByM;
-  //
-  // }
-  //
-  // static REAL8 UNUSED
-  // XLALSimInspiralTaylorF2Phasing_12PNTidalCoeff(
-  // 	REAL8 mByM /**< ratio of object mass to total mass */
-  //     )
-  // {
-  //   return (-15895./28. + 4595./28.*mByM + 5715./14.*mByM*mByM - 325./7.*mByM*mByM*mByM)*mByM*mByM*mByM*mByM;
-  // }
-
-  // implement this as a separate function
-  // amplitude taylorf2_amp()
-  // https://github.com/benjaminlackey/gpsurrogate/blob/master/src/taylorf2.py#L59
-
-
-  // Glue amplitude
-  gsl_interp_accel *acc_amp;
-  gsl_spline *spline_amp;
-  GlueAmplitude(submodel_lo, submodel_hi, amp_f_lo, amp_f_hi, amp_pre_lo, amp_pre_hi, Mfm,
-    &acc_amp, &spline_amp
-  );
-
-  // Glue phasing in frequency to C^1 smoothness
-  gsl_interp_accel *acc_phi;
-  gsl_spline *spline_phi;
-  GluePhasing(submodel_lo, submodel_hi, phi_f_lo, phi_f_hi, Mfm,
-    &acc_phi, &spline_phi
-  );
-
   size_t npts = 0;
   LIGOTimeGPS tC = {0, 0};
   UINT4 offset = 0; // Index shift between freqs and the frequency series
@@ -1600,8 +943,6 @@ gsl_spline_init(spline_ampNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), //
       gsl_spline_free(spline_phi);
       gsl_interp_accel_free(acc_amp);
       gsl_interp_accel_free(acc_phi);
-      TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_lo);
-      TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_hi);
       XLAL_ERROR(XLAL_EFUNC);
   }
   memset((*hptilde)->data->data, 0, npts * sizeof(COMPLEX16));
@@ -1623,49 +964,33 @@ gsl_spline_init(spline_ampNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), //
   // Evaluate reference phase for setting phiRef correctly
   double phase_change = gsl_spline_eval(spline_phi, fRef_geom, acc_phi) - 2*phiRef;
 
-  // Assemble waveform from aplitude and phase
-  for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
-    double f = freqs->data[i];
-    if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
-    int j = i + offset; // shift index for frequency series if needed
-    double A = gsl_spline_eval(spline_amp, f, acc_amp);
-    double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
-    COMPLEX16 htilde = s*amp0*A * (cos(phase) + I*sin(phase));//cexp(I*phase);
-    pdata[j] =      pcoef * htilde;
-    cdata[j] = -I * ccoef * htilde;
-  }
+  // Compute BNS merger frequency
+  TidalEOBParams tidal1, tidal2;
+  tidal1.mByM = q / (1.0+q);
+  tidal1.lambda2Tidal = lambda1 * pow(tidal1.mByM,5);
+  tidal2.mByM = 1.0 / (1.0+q);
+  tidal2.lambda2Tidal = lambda2 * pow(tidal2.mByM,5);
+  double Momega22_BNS_mrg = XLALSimNSNSMergerFreq(&tidal1, &tidal2);
+  fprintf(stderr, "Momega22_BNS_mrg = %g\n", Momega22_BNS_mrg);
 
+  Mf_ROM_max = gsl_vector_get(submodel_lo->mf_phi, N_phi-1);
+  double Mf_final = fmin(Momega22_BNS_mrg, Mf_ROM_max);
 
   // Assemble waveform from aplitude and phase
-  // FIXME: Temporary code block to output TEOB surrogate waveform
-  // Wipe the arrays clean again: remove this later
-  memset((*hptilde)->data->data, 0, npts * sizeof(COMPLEX16));
-  memset((*hctilde)->data->data, 0, npts * sizeof(COMPLEX16));
-  phase_change = gsl_spline_eval(spline_phiNEW, fRef_geom, acc_phiNEW) - 2*phiRef;
-  Mf_ROM_max = gsl_vector_get(submodel_lo->mf_phi, N_phi-1);
   fprintf(stderr, "Mf_ROM_max = %g\n", Mf_ROM_max);
   for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
     double f = freqs->data[i];
-    if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
+    if (f > Mf_final) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
     int j = i + offset; // shift index for frequency series if needed
-    double A = gsl_spline_eval(spline_ampNEW, f, acc_ampNEW);
-    double phase = gsl_spline_eval(spline_phiNEW, f, acc_phiNEW) - phase_change;
+    double A = gsl_spline_eval(spline_amp, f, acc_amp);
+    double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
     fprintf(stderr, "%d, %d    %g : %g %g\n", i, j, f, A, phase);
     COMPLEX16 htilde = s*amp0*A * (cos(phase) + I*sin(phase));//cexp(I*phase);
     pdata[j] =      pcoef * htilde;
     cdata[j] = -I * ccoef * htilde;
   }
 
-
   /* Correct phasing so we coalesce at t=0 (with the definition of the epoch=-1/deltaF above) */
-
-  // Get SEOBNRv4 ringdown frequency for 22 mode
-  double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(Mtot_sec, eta, chi1,
-                                                        chi2, SEOBNRv4);
-
-  // FIXME: we need a function we can call for the BNS merger frequency!
-  Mf_final = 0.07; // FIXME: hack for now use Mf_max from surrogate
-
   UINT4 L = freqs->length;
   // prevent gsl interpolation errors
   if (Mf_final > freqs->data[L-1])
@@ -1676,8 +1001,6 @@ gsl_spline_init(spline_ampNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), //
     gsl_spline_free(spline_phi);
     gsl_interp_accel_free(acc_amp);
     gsl_interp_accel_free(acc_phi);
-    TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_lo);
-    TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_hi);
     XLAL_ERROR(XLAL_EDOM, "f_ringdown < f_min");
   }
 
@@ -1697,21 +1020,10 @@ gsl_spline_init(spline_ampNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), //
 
   XLALDestroyREAL8Sequence(freqs);
 
-  gsl_spline_free(spline_amp);
+  gsl_interp_accel_free(acc_phi);
   gsl_spline_free(spline_phi);
   gsl_interp_accel_free(acc_amp);
-  gsl_interp_accel_free(acc_phi);
-  TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_lo);
-  TEOBv4ROMdataDS_coeff_Cleanup(romdata_coeff_hi);
-
-
-
-  // FIXME: make sure everything is freed also in case of errors
-  gsl_interp_accel_free(acc_phiNEW);
-  gsl_spline_free(spline_phiNEW);
-  gsl_interp_accel_free(acc_ampNEW);
-  gsl_spline_free(spline_ampNEW);
-
+  gsl_spline_free(spline_amp);
 
   return(XLAL_SUCCESS);
 }
@@ -1737,7 +1049,7 @@ gsl_spline_init(spline_ampNEW, gsl_vector_const_ptr(submodel_lo->mf_phi, 0), //
  *   * q
  *   * chi_i
  *   * lambda_i
- *   * 2Msun (@ flow=20Hz) <= Mtot < 500Msun
+ *   * 2Msun (@ flow=20Hz) <= Mtot
  *
  *  Aligned component spins chi1, chi2.
  *  Symmetric mass-ratio eta = m1*m2/(m1+m2)^2.
@@ -1777,8 +1089,7 @@ int XLALSimIMRTEOBv4ROMFrequencySequence(
   REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
   REAL8 chi2,                                   /**< Dimensionless aligned component spin 2 */
   REAL8 lambda1,                                /**< Dimensionless tidal deformability 1 */
-  REAL8 lambda2,                                /**< Dimensionless tidal deformability 2 */
-  INT4 nk_max)                                  /**< Truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1 */
+  REAL8 lambda2)                                /**< Dimensionless tidal deformability 2 */
 {
   /* Internally we need m1 > m2, so change around if this is not the case */
   if (m1SI < m2SI) {
@@ -1815,8 +1126,7 @@ int XLALSimIMRTEOBv4ROMFrequencySequence(
   // Call the internal core function with deltaF = 0 to indicate that freqs is non-uniformly
   // spaced and we want the strain only at these frequencies
   int retcode = TEOBv4ROMCore(hptilde, hctilde, phiRef, fRef, distance,
-                                inclination, Mtot_sec, eta, chi1, chi2, lambda1, lambda2, freqs,
-                                0, nk_max);
+                                inclination, Mtot_sec, eta, chi1, chi2, lambda1, lambda2, freqs, 0);
 
   return(retcode);
 }
@@ -1843,8 +1153,7 @@ int XLALSimIMRTEOBv4ROM(
   REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
   REAL8 chi2,                                   /**< Dimensionless aligned component spin 2 */
   REAL8 lambda1,                                /**< Dimensionless tidal deformability 1 */
-  REAL8 lambda2,                                /**< Dimensionless tidal deformability 2 */
-  INT4 nk_max)                                  /**< Truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1 */
+  REAL8 lambda2)                                /**< Dimensionless tidal deformability 2 */
 {
   /* Internally we need m1 > m2, so change around if this is not the case */
   if (m1SI < m2SI) {
@@ -1882,8 +1191,7 @@ int XLALSimIMRTEOBv4ROM(
   freqs->data[1] = fHigh;
 
   int retcode = TEOBv4ROMCore(hptilde, hctilde, phiRef, fRef, distance,
-                                inclination, Mtot_sec, eta, chi1, chi2, lambda1, lambda2, freqs,
-                                deltaF, nk_max);
+                                inclination, Mtot_sec, eta, chi1, chi2, lambda1, lambda2, freqs, deltaF);
 
   XLALDestroyREAL8Sequence(freqs);
 
-- 
2.5.4 (Apple Git-61)

